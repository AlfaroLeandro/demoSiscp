package com.example.demo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.deeplearning4j.datasets.iterator.utilty.ListDataSetIterator;
import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.OutputLayer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.nn.weights.WeightInit;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.DataSet;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.learning.config.Adam;
import org.nd4j.linalg.lossfunctions.LossFunctions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;

	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody String addNewUser(@RequestParam String name, @RequestParam String email) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		User n = new User();
		n.setName(name);
		n.setEmail(email);
		userRepository.save(n);
		return "Saved";
	}

	@GetMapping(path = "/all")
	public @ResponseBody Iterable<User> getAllUsers() {
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}

	@GetMapping(path = "/hql")
	public @ResponseBody Iterable<User> hql() {
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}

	@GetMapping(path = "/hqlParam")
	public @ResponseBody User hqlParam() {
		// This returns a JSON or XML with the users
		return userRepository.findByLastnameOrFirstname("leandro");
	}

	@GetMapping("/hello-world")
	public String helloWorld(Model model) {
		model.addAttribute("message", "Hello World!");
		return "hello-world";
	}
	
	@GetMapping("/ml")
	public @ResponseBody String ml() {
		MultiLayerConfiguration config = new NeuralNetConfiguration.Builder()
			    .seed(123) // Semilla para reproducibilidad
			    .weightInit(WeightInit.XAVIER) // Inicialización de pesos
			    .activation(Activation.RELU) // Función de activación de las capas ocultas
			    .updater(new Adam()) // Optimizador Adam
			    .list()
			    .layer(new DenseLayer.Builder()
			        .nIn(2) // Número de entradas
			        .nOut(32) // Número de neuronas en la capa oculta
			        .build())
			    .layer(new OutputLayer.Builder(LossFunctions.LossFunction.MSE)
			        .nIn(32) // Número de entradas de la capa de salida
			        .nOut(2) // Número de salidas
			        .activation(Activation.IDENTITY) // Función de activación de la capa de salida
			        .build())
			    .build();
		
		List<INDArray> trazas = obtenerTrazasDeCoordenadas();
//		INDArray trazasConcatenadas = Nd4j.concat(1, trazas.toArray(new INDArray[0]));
//		INDArray trazasConcatenadas = Nd4j.stack(trazas.size(), trazas.toArray(new INDArray[0]));
		
		// Crear la instancia del modelo
		MultiLayerNetwork model = new MultiLayerNetwork(config);
		model.init();
		
//		DataSet dataset = new DataSet(trazasConcatenadas);
		
		int batchSize = 16;
		// Entrenar el modelo
		for(int i = 0; i<trazas.size(); i++) {
			DataSet dataSet = new DataSet(trazas.get(i), trazas.get(i));
			ListDataSetIterator trainIterator = new ListDataSetIterator(dataSet.asList(), batchSize);
			model.fit(trainIterator);
		}
		INDArray coordenada = Nd4j.create(1,2).putScalar(0, 0, 2.37).putScalar(0, 1, 1.447);
		var resultado = model.output(coordenada);
		
		System.out.println("Prediccion: " + resultado); 
		
		return resultado.toString();
	}

	private List<INDArray> obtenerTrazasDeCoordenadas() {
		List<INDArray> trazas = new ArrayList<>();
		// Supongamos que tienes un conjunto de trazas en forma de lista de listas de listas
		List<List<List<Double>>> conjuntoTrazas = Arrays.asList(
		        Arrays.asList(
		                Arrays.asList(1.0, 2.0),
		                Arrays.asList(3.0, 4.0)
		        ),
		        Arrays.asList(
		                Arrays.asList(2.0, 3.0),
		                Arrays.asList(3.0, 4.0)
		        )
		);
		
		for(List<List<Double>> traza : conjuntoTrazas) {
			INDArray indTraza = Nd4j.create(traza.size(), 2);
			for(int i = 0; i<traza.size(); i++) {
				indTraza.putScalar(i, 0, traza.get(i).get(0)); //pongo la latitud
				indTraza.putScalar(i, 1, traza.get(i).get(1)); //pongo la longitud
			}
			trazas.add(indTraza);
		}
		
		return trazas;
	}
}